/*
19.
Cree el/los objetos de base de datos necesarios para que se cumpla la siguiente
regla de negocio automáticamente: "Ningún jefe puede tener menos de 5 años de
antigüedad y tampoco puede tener más del 50% del personal a su cargo
(contando directos e indirectos) a excepción del gerente general". Se sabe que en
la actualidad la regla se cumple y existe un único gerente general.*/use GD2015C1gocreate trigger ej19 on empleadofor insert, updateasbegin	if exists(		select *		from inserted		where			1 = -- No me gusta para nada			case 				when dbo.esGerenteGeneral(empl_codigo) = 1 --Es malísimo: como no hay bool hay que igualar a 1					then 0 --Se filtra (no pasa nada)				when year(getdate()) - year(empl_ingreso) < 5 and					dbo.cantidad_subempleados(empl_codigo) > (select count(*) from deleted)					then 1 --No se filtra, por lo que el select va a quedar con al menos una fila y el if exists() va a dar true			end	)		rollbackendgocreate function esGerenteGeneral (@empl_codigo numeric(6))returns intasbegin	--Los dos if son dos formas distintas de hacerlo	if not exists(select * from empleado where empl_jefe = @empl_codigo) -- Si hay algún subempleado		return 1	if dbo.cantidad_subempleados(@empl_codigo) = (select count(*) from empleado) - 1 -- Si la cantidad de los subempleados = personal total (-1 porque es él mismo)		return 1	return 0endgoalter function cantidad_subempleados (@jefe_codigo numeric(6))returns intasbegin	return (		select isnull(sum(dbo.cantidad_subempleados(empl_codigo) + 1), 0)		from empleado		where empl_jefe = @jefe_codigo	)endgoselect empl_codigo, dbo.cantidad_subempleados(empl_codigo) 'Subempleados' from empleado/*En vez de	year(getdate()) - year(empl_ingreso)la parte de cálculo del año también podría haberse hecho de la siguiente manera:	datediff(year, getdate(), empl_ingreso)*/